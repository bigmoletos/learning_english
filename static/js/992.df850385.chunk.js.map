{"version":3,"file":"static/js/992.df850385.chunk.js","mappings":"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","sources":["services/firebase/firebaseConfig.generated.ts","services/firebase/config.ts","services/firebase/firestoreService.ts","services/firebase/userService.ts"],"sourcesContent":["/**\n * Configuration Firebase g√©n√©r√©e automatiquement\n * ‚ö†Ô∏è NE PAS MODIFIER CE FICHIER MANUELLEMENT\n * Il est g√©n√©r√© par scripts/copy-env-to-build.js\n */\n\nexport const firebaseConfigGenerated = {\n  apiKey: \"AIzaSyA4VxXsU3yI3GedYREVkUIOgHo8NU1DUsw\",\n  authDomain: \"ia-project-91c03.firebaseapp.com\",\n  projectId: \"ia-project-91c03\",\n  storageBucket: \"ia-project-91c03.firebasestorage.app\",\n  messagingSenderId: \"764765123671\",\n  appId: \"1:764765123671:web:c6861709d1a881fcfe1f12\",\n  measurementId: \"\",\n};\n","/**\n * Configuration Firebase\n * @version 2.0.0\n * @date 07-11-2025\n */\n\nimport { initializeApp, FirebaseApp } from \"firebase/app\";\nimport { getFirestore, Firestore } from \"firebase/firestore\";\nimport { getAuth, Auth } from \"firebase/auth\";\nimport { getStorage, FirebaseStorage } from \"firebase/storage\";\nimport { firebaseConfigGenerated } from \"./firebaseConfig.generated\";\n\n// V√©rifier si on est sur Capacitor/Android\nconst isCapacitor = typeof (window as any).Capacitor !== \"undefined\";\nconst platform = isCapacitor ? (window as any).Capacitor?.getPlatform() : \"web\";\n\n// Initialiser Firebase\nlet app: FirebaseApp | null = null;\nlet db: Firestore | null = null;\nlet auth: Auth | null = null;\nlet storage: FirebaseStorage | null = null;\n\ntry {\n  // Utiliser la configuration g√©n√©r√©e (fonctionne en dev et prod)\n  app = initializeApp(firebaseConfigGenerated);\n  db = getFirestore(app);\n  auth = getAuth(app);\n  storage = getStorage(app);\n\n  console.log(`‚úÖ Firebase initialis√© avec succ√®s (${platform})`);\n} catch (error) {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  console.error(`‚ùå Erreur Firebase (${platform}):`, errorMessage);\n\n  // Sur mobile, ne pas crasher l'app\n  if (isCapacitor) {\n    console.warn(\"Mode offline activ√© pour Capacitor\");\n  }\n}\n\nexport { app, db, auth, storage };\nconst firebaseConfig = { app, db, auth, storage };\nexport default firebaseConfig;\n","/**\n * Service Firestore g√©n√©rique pour op√©rations CRUD\n * @version 1.2.0\n * @date 2025-11-19\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  Timestamp,\n  QueryConstraint,\n  DocumentData,\n} from \"firebase/firestore\";\nimport { db, auth } from \"./config\";\nimport { logger } from \"../logger\";\n\n/**\n * V√©rifie si l'utilisateur est authentifi√©\n * Retourne true si authentifi√©, false sinon\n */\nconst isAuthenticated = (): boolean => {\n  if (!auth) {\n    return false;\n  }\n  return !!auth.currentUser;\n};\n\n/**\n * Convertit un objet Firestore avec Timestamp en objet JavaScript standard\n */\nexport const convertTimestamps = (data: any): any => {\n  if (!data) return null;\n\n  const converted: any = { ...data };\n\n  Object.keys(converted).forEach((key) => {\n    // V√©rifier si c'est un Timestamp Firebase (peut √™tre un objet avec toDate)\n    if (\n      converted[key] &&\n      typeof converted[key] === \"object\" &&\n      typeof converted[key].toDate === \"function\"\n    ) {\n      converted[key] = converted[key].toDate();\n    } else if (\n      converted[key] &&\n      typeof converted[key] === \"object\" &&\n      !Array.isArray(converted[key])\n    ) {\n      converted[key] = convertTimestamps(converted[key]);\n    }\n  });\n\n  return converted;\n};\n\n/**\n * Obtient un document par ID\n */\nexport const getDocument = async <T = DocumentData>(\n  collectionName: string,\n  documentId: string\n): Promise<T | null> => {\n  if (!db) {\n    logger.warn(\"Firestore n'est pas initialis√©\");\n    return null;\n  }\n\n  try {\n    const docRef = doc(db, collectionName, documentId);\n    const docSnap = await getDoc(docRef);\n\n    if (docSnap.exists()) {\n      const data = docSnap.data();\n      return convertTimestamps({ ...data, id: docSnap.id }) as T;\n    }\n\n    return null;\n  } catch (error: any) {\n    // G√©rer silencieusement les erreurs offline, d'authentification ou de permission\n    if (\n      error.code === \"unavailable\" ||\n      error.code === \"failed-precondition\" ||\n      error.code === \"permission-denied\" ||\n      error.code === \"unauthenticated\" ||\n      error.message?.includes(\"offline\") ||\n      error.message?.includes(\"network\") ||\n      error.message?.includes(\"permission\") ||\n      error.message?.includes(\"authenticated\")\n    ) {\n      // Client offline ou non authentifi√© - retourner null silencieusement\n      logger.debug(\"Client offline ou non authentifi√© lors de getDocument\", {\n        collection: collectionName,\n        documentId,\n        errorCode: error.code,\n      });\n      return null;\n    }\n    // Ne logger que les autres erreurs\n    logger.error(\n      `Erreur lors de la r√©cup√©ration du document ${collectionName}/${documentId}`,\n      error\n    );\n    throw error;\n  }\n};\n\n/**\n * Obtient tous les documents d'une collection avec filtres optionnels\n */\nexport const getDocuments = async <T = DocumentData>(\n  collectionName: string,\n  constraints: QueryConstraint[] = []\n): Promise<T[]> => {\n  if (!db) {\n    logger.warn(\"Firestore n'est pas initialis√©\");\n    return [];\n  }\n\n  try {\n    const collectionRef = collection(db, collectionName);\n    const q = constraints.length > 0 ? query(collectionRef, ...constraints) : query(collectionRef);\n\n    const querySnapshot = await getDocs(q);\n    const documents: T[] = [];\n\n    querySnapshot.forEach((docSnap) => {\n      const data = docSnap.data();\n      documents.push(convertTimestamps({ ...data, id: docSnap.id }) as T);\n    });\n\n    return documents;\n  } catch (error: any) {\n    // G√©rer silencieusement les erreurs offline, d'authentification ou de permission\n    if (\n      error.code === \"unavailable\" ||\n      error.code === \"failed-precondition\" ||\n      error.code === \"permission-denied\" ||\n      error.code === \"unauthenticated\" ||\n      error.message?.includes(\"offline\") ||\n      error.message?.includes(\"network\") ||\n      error.message?.includes(\"permission\") ||\n      error.message?.includes(\"authenticated\")\n    ) {\n      // Client offline ou non authentifi√© - retourner un tableau vide silencieusement\n      logger.debug(\"Client offline ou non authentifi√© lors de getDocuments\", {\n        collection: collectionName,\n        errorCode: error.code,\n      });\n      return [];\n    }\n    // Ne logger que les autres erreurs\n    logger.error(`Erreur lors de la r√©cup√©ration des documents ${collectionName}`, error);\n    throw error;\n  }\n};\n\n/**\n * Cr√©e ou met √† jour un document\n */\nexport const setDocument = async <T = DocumentData>(\n  collectionName: string,\n  documentId: string,\n  data: Partial<T>\n): Promise<void> => {\n  if (!db) {\n    logger.warn(\"Firestore n'est pas initialis√©\");\n    return;\n  }\n\n  // V√©rifier l'authentification avant l'√©criture\n  if (!isAuthenticated() || !auth || !auth.currentUser) {\n    throw new Error(\"Utilisateur non authentifi√©. Impossible de sauvegarder dans Firestore.\");\n  }\n\n  // V√©rifier que le documentId correspond √† l'UID de l'utilisateur pour la collection users\n  const currentUser = auth?.currentUser;\n  if (collectionName === \"users\" && currentUser && documentId !== currentUser.uid) {\n    const errorMsg = `UID mismatch: documentId=${documentId}, auth.uid=${currentUser.uid}`;\n    logger.error(errorMsg);\n    throw new Error(errorMsg);\n  }\n\n  try {\n    logger.debug(`Pr√©paration sauvegarde: ${collectionName}/${documentId}`, {\n      authUid: auth.currentUser?.uid,\n      dataKeys: Object.keys(data || {}),\n      dataSize: JSON.stringify(data).length,\n    });\n\n    const docRef = doc(db, collectionName, documentId);\n\n    // Convertir les dates en Timestamp Firestore\n    logger.debug(\"Conversion des dates...\");\n    const firestoreData: any = { ...data };\n    let convertedDates = 0;\n    Object.keys(firestoreData).forEach((key) => {\n      if (firestoreData[key] instanceof Date) {\n        firestoreData[key] = Timestamp.fromDate(firestoreData[key]);\n        convertedDates++;\n      } else if (\n        firestoreData[key] &&\n        typeof firestoreData[key] === \"string\" &&\n        firestoreData[key].match(/^\\d{4}-\\d{2}-\\d{2}T/)\n      ) {\n        // Convertir les cha√Ænes ISO en Timestamp\n        try {\n          firestoreData[key] = Timestamp.fromDate(new Date(firestoreData[key]));\n          convertedDates++;\n        } catch (e) {\n          logger.warn(`Impossible de convertir la date pour ${key}`, {\n            value: firestoreData[key],\n          });\n        }\n      }\n    });\n\n    if (convertedDates > 0) {\n      logger.debug(`${convertedDates} date(s) convertie(s)`);\n    }\n\n    // V√©rifier que les donn√©es essentielles sont pr√©sentes\n    if (collectionName === \"users\" && !firestoreData.email) {\n      logger.warn(\"Tentative de sauvegarde utilisateur sans email\", {\n        id: firestoreData.id,\n        keys: Object.keys(firestoreData),\n      });\n    }\n\n    await setDoc(\n      docRef,\n      {\n        ...firestoreData,\n        updatedAt: Timestamp.now(),\n      },\n      { merge: true }\n    );\n\n    logger.info(`Document sauvegard√© avec succ√®s: ${collectionName}/${documentId}`);\n  } catch (error: any) {\n    // Logger l'erreur compl√®te pour diagnostic\n    logger.error(\n      `Erreur lors de la sauvegarde du document ${collectionName}/${documentId}`,\n      error,\n      {\n        code: error.code,\n        collection: collectionName,\n        documentId: documentId,\n        authUid: auth.currentUser?.uid || \"non authentifi√©\",\n        dataKeys: Object.keys(data || {}),\n      }\n    );\n\n    // Si c'est une erreur de permission, donner plus de d√©tails\n    if (error.code === \"permission-denied\") {\n      logger.error(\n        \"Permission refus√©e. V√©rifiez les r√®gles Firestore et l'authentification\",\n        undefined,\n        {\n          authUid: auth.currentUser?.uid,\n          collection: collectionName,\n          documentId,\n        }\n      );\n    } else if (error.code === \"unauthenticated\") {\n      logger.error(\"Utilisateur non authentifi√©. V√©rifiez Firebase Auth\", undefined, {\n        collection: collectionName,\n        documentId,\n      });\n    }\n\n    throw error;\n  }\n};\n\n/**\n * Met √† jour un document existant\n */\nexport const updateDocument = async <T = DocumentData>(\n  collectionName: string,\n  documentId: string,\n  data: Partial<T>\n): Promise<void> => {\n  if (!db) {\n    logger.warn(\"Firestore n'est pas initialis√©\");\n    return;\n  }\n\n  // V√©rifier l'authentification avant l'√©criture\n  if (!isAuthenticated() || !auth || !auth.currentUser) {\n    throw new Error(\"Utilisateur non authentifi√©. Impossible de mettre √† jour dans Firestore.\");\n  }\n\n  try {\n    logger.debug(`Pr√©paration mise √† jour: ${collectionName}/${documentId}`, {\n      authUid: auth?.currentUser?.uid,\n      dataKeys: Object.keys(data || {}),\n      dataSize: JSON.stringify(data).length,\n    });\n\n    const docRef = doc(db, collectionName, documentId);\n\n    // Convertir les dates en Timestamp Firestore\n    const firestoreData: any = { ...data };\n    let convertedDates = 0;\n    Object.keys(firestoreData).forEach((key) => {\n      if (firestoreData[key] instanceof Date) {\n        firestoreData[key] = Timestamp.fromDate(firestoreData[key]);\n        convertedDates++;\n      } else if (\n        firestoreData[key] &&\n        typeof firestoreData[key] === \"string\" &&\n        firestoreData[key].match(/^\\d{4}-\\d{2}-\\d{2}T/)\n      ) {\n        try {\n          firestoreData[key] = Timestamp.fromDate(new Date(firestoreData[key]));\n          convertedDates++;\n        } catch (e) {\n          logger.warn(`Impossible de convertir la date pour ${key}`, {\n            value: firestoreData[key],\n          });\n        }\n      }\n    });\n\n    if (convertedDates > 0) {\n      logger.debug(`${convertedDates} date(s) convertie(s)`);\n    }\n\n    await updateDoc(docRef, {\n      ...firestoreData,\n      updatedAt: Timestamp.now(),\n    });\n\n    logger.info(`Document mis √† jour avec succ√®s: ${collectionName}/${documentId}`);\n  } catch (error: any) {\n    logger.error(\n      `Erreur lors de la mise √† jour du document ${collectionName}/${documentId}`,\n      error,\n      {\n        code: error.code,\n        collection: collectionName,\n        documentId: documentId,\n        authUid: auth.currentUser?.uid || \"non authentifi√©\",\n        dataKeys: Object.keys(data || {}),\n      }\n    );\n    throw error;\n  }\n};\n\n/**\n * Supprime un document\n */\nexport const deleteDocument = async (collectionName: string, documentId: string): Promise<void> => {\n  if (!db) {\n    logger.warn(\"Firestore n'est pas initialis√©\");\n    return;\n  }\n\n  // V√©rifier l'authentification avant la suppression\n  if (!isAuthenticated() || !auth || !auth.currentUser) {\n    throw new Error(\"Utilisateur non authentifi√©. Impossible de supprimer dans Firestore.\");\n  }\n\n  try {\n    logger.debug(`Suppression: ${collectionName}/${documentId}`, {\n      authUid: auth?.currentUser?.uid,\n    });\n\n    const docRef = doc(db, collectionName, documentId);\n    await deleteDoc(docRef);\n\n    logger.info(`Document supprim√© avec succ√®s: ${collectionName}/${documentId}`);\n  } catch (error: any) {\n    logger.error(\n      `Erreur lors de la suppression du document ${collectionName}/${documentId}`,\n      error,\n      {\n        code: error.code,\n        collection: collectionName,\n        documentId: documentId,\n        authUid: auth.currentUser?.uid || \"non authentifi√©\",\n      }\n    );\n    throw error;\n  }\n};\n\n/**\n * Obtient les documents d'une collection filtr√©s par un champ\n */\nexport const getDocumentsByField = async <T = DocumentData>(\n  collectionName: string,\n  field: string,\n  value: any,\n  orderByField?: string,\n  orderDirection: \"asc\" | \"desc\" = \"asc\",\n  maxResults?: number\n): Promise<T[]> => {\n  const constraints: QueryConstraint[] = [where(field, \"==\", value)];\n\n  if (orderByField) {\n    constraints.push(orderBy(orderByField, orderDirection));\n  }\n\n  if (maxResults) {\n    constraints.push(limit(maxResults));\n  }\n\n  return getDocuments<T>(collectionName, constraints);\n};\n\n/**\n * Obtient les documents d'une collection ordonn√©s par un champ\n */\nexport const getDocumentsOrdered = async <T = DocumentData>(\n  collectionName: string,\n  orderByField: string,\n  orderDirection: \"asc\" | \"desc\" = \"desc\",\n  maxResults?: number\n): Promise<T[]> => {\n  const constraints: QueryConstraint[] = [orderBy(orderByField, orderDirection)];\n\n  if (maxResults) {\n    constraints.push(limit(maxResults));\n  }\n\n  return getDocuments<T>(collectionName, constraints);\n};\n\n/**\n * V√©rifie si un document existe\n */\nexport const documentExists = async (\n  collectionName: string,\n  documentId: string\n): Promise<boolean> => {\n  if (!db) {\n    return false;\n  }\n\n  try {\n    const docRef = doc(db, collectionName, documentId);\n    const docSnap = await getDoc(docRef);\n    return docSnap.exists();\n  } catch (error) {\n    console.error(\n      `Erreur lors de la v√©rification de l'existence du document ${collectionName}/${documentId}:`,\n      error\n    );\n    return false;\n  }\n};\n","/**\n * Service Firestore pour gestion des utilisateurs\n * @version 1.0.0\n * @date 01-11-2025\n */\n\nimport {\n  getDocument,\n  setDocument,\n  updateDocument,\n  deleteDocument,\n  getDocumentsByField,\n  documentExists,\n} from \"./firestoreService\";\nimport { UserProfile } from \"../../types\";\n\nconst COLLECTION_NAME = \"users\";\n\nexport interface FirestoreUser {\n  id: string;\n  email: string;\n  firstName?: string;\n  lastName?: string;\n  currentLevel: \"A1\" | \"A2\" | \"B1\" | \"B2\" | \"C1\";\n  targetLevel: \"A1\" | \"A2\" | \"B1\" | \"B2\" | \"C1\";\n  weaknesses?: string[];\n  completedExercises?: number;\n  totalScore?: number;\n  levelAssessed?: boolean; // Indique si l'utilisateur a compl√©t√© le test d'√©valuation\n  assessmentCompletedAt?: Date; // Date de compl√©tion du test d'√©valuation\n  createdAt: Date;\n  updatedAt: Date;\n  lastActivity?: Date;\n}\n\n/**\n * Convertit un UserProfile en FirestoreUser\n */\nconst toFirestoreUser = (user: UserProfile): Partial<FirestoreUser> => {\n  // Extraire l'email depuis user.email ou user.name si email n'est pas disponible\n  const userEmail = (user as any).email || user.name || \"\";\n\n  return {\n    id: user.id,\n    email: userEmail,\n    firstName: (user as any).firstName,\n    lastName: (user as any).lastName,\n    currentLevel: user.currentLevel,\n    targetLevel: user.targetLevel,\n    weaknesses: user.weaknesses,\n    completedExercises: user.completedExercises,\n    totalScore: user.totalScore,\n    createdAt:\n      user.createdAt instanceof Date ? user.createdAt : new Date(user.createdAt || Date.now()),\n    updatedAt: new Date(),\n    lastActivity:\n      user.lastActivity instanceof Date\n        ? user.lastActivity\n        : user.lastActivity\n          ? new Date(user.lastActivity)\n          : undefined,\n  };\n};\n\n/**\n * Convertit un FirestoreUser en UserProfile\n */\nconst toUserProfile = (firestoreUser: FirestoreUser): UserProfile => {\n  return {\n    id: firestoreUser.id,\n    name:\n      firestoreUser.email ||\n      `${firestoreUser.firstName || \"\"} ${firestoreUser.lastName || \"\"}`.trim() ||\n      \"Utilisateur\",\n    currentLevel: firestoreUser.currentLevel,\n    targetLevel: firestoreUser.targetLevel,\n    strengths: [],\n    weaknesses: firestoreUser.weaknesses || [],\n    completedExercises: firestoreUser.completedExercises || 0,\n    totalScore: firestoreUser.totalScore || 0,\n    createdAt: firestoreUser.createdAt,\n    lastActivity: firestoreUser.lastActivity || firestoreUser.updatedAt,\n  };\n};\n\n/**\n * Obtient un utilisateur par ID\n */\nexport const getUserById = async (userId: string): Promise<UserProfile | null> => {\n  const firestoreUser = await getDocument<FirestoreUser>(COLLECTION_NAME, userId);\n  return firestoreUser ? toUserProfile(firestoreUser) : null;\n};\n\n/**\n * Obtient le statut d'√©valuation de niveau d'un utilisateur\n */\nexport const getUserAssessmentStatus = async (userId: string): Promise<boolean> => {\n  const firestoreUser = await getDocument<FirestoreUser>(COLLECTION_NAME, userId);\n  return firestoreUser?.levelAssessed || false;\n};\n\n/**\n * Obtient un utilisateur par email\n */\nexport const getUserByEmail = async (email: string): Promise<UserProfile | null> => {\n  const users = await getDocumentsByField<FirestoreUser>(COLLECTION_NAME, \"email\", email);\n  return users.length > 0 ? toUserProfile(users[0]) : null;\n};\n\n/**\n * Cr√©e ou met √† jour un utilisateur\n */\nexport const saveUser = async (user: UserProfile): Promise<void> => {\n  console.log(\"üíæ [saveUser] D√©but sauvegarde utilisateur:\", {\n    userId: user.id,\n    email: (user as any).email,\n    name: user.name,\n  });\n\n  try {\n    // V√©rifier que l'utilisateur a un ID valide\n    if (!user.id) {\n      const error = new Error(\"L'utilisateur doit avoir un ID pour √™tre sauvegard√© dans Firestore\");\n      console.error(\"‚ùå [saveUser]\", error.message);\n      throw error;\n    }\n\n    console.log(\"üîÑ [saveUser] Conversion en FirestoreUser...\");\n    const firestoreUser = toFirestoreUser(user);\n    console.log(\"‚úÖ [saveUser] Conversion r√©ussie:\", {\n      id: firestoreUser.id,\n      email: firestoreUser.email,\n      hasFirstName: !!firestoreUser.firstName,\n      hasLastName: !!firestoreUser.lastName,\n    });\n\n    // Extraire l'email - c'est obligatoire pour Firestore\n    const userEmail = firestoreUser.email || (user as any).email || \"\";\n    if (!userEmail) {\n      const error = new Error(\n        \"L'utilisateur doit avoir un email pour √™tre sauvegard√© dans Firestore\"\n      );\n      console.error(\"‚ùå [saveUser]\", error.message, {\n        userData: {\n          id: user.id,\n          name: user.name,\n          hasEmail: !!(user as any).email,\n        },\n      });\n      throw error;\n    }\n\n    console.log(\"üîß [saveUser] Construction des donn√©es Firestore...\");\n    // S'assurer que toutes les propri√©t√©s requises sont pr√©sentes\n    const userData: Partial<FirestoreUser> = {\n      id: user.id,\n      email: userEmail,\n      currentLevel: user.currentLevel,\n      targetLevel: user.targetLevel,\n      createdAt:\n        firestoreUser.createdAt instanceof Date\n          ? firestoreUser.createdAt\n          : new Date(firestoreUser.createdAt || Date.now()),\n      updatedAt: new Date(),\n      ...(firestoreUser.firstName && { firstName: firestoreUser.firstName }),\n      ...(firestoreUser.lastName && { lastName: firestoreUser.lastName }),\n      ...(user.weaknesses && user.weaknesses.length > 0 && { weaknesses: user.weaknesses }),\n      ...(user.completedExercises !== undefined && { completedExercises: user.completedExercises }),\n      ...(user.totalScore !== undefined && { totalScore: user.totalScore }),\n      ...(firestoreUser.lastActivity && {\n        lastActivity:\n          firestoreUser.lastActivity instanceof Date\n            ? firestoreUser.lastActivity\n            : new Date(firestoreUser.lastActivity),\n      }),\n    };\n\n    console.log(\"üíæ [saveUser] Donn√©es pr√©par√©es:\", {\n      userId: user.id,\n      email: userEmail,\n      currentLevel: userData.currentLevel,\n      targetLevel: userData.targetLevel,\n      dataKeys: Object.keys(userData),\n    });\n\n    console.log(\"üåê [saveUser] Appel setDocument...\");\n    await setDocument<FirestoreUser>(COLLECTION_NAME, user.id, userData);\n    console.log(\"‚úÖ [saveUser] Utilisateur sauvegard√© avec succ√®s dans Firestore\");\n  } catch (error: any) {\n    console.error(\"‚ùå [saveUser] Erreur lors de la sauvegarde:\", {\n      code: error.code,\n      message: error.message,\n      stack: error.stack,\n      userId: user.id,\n      email: (user as any).email,\n      error: error,\n    });\n    throw error;\n  }\n};\n\n/**\n * Met √† jour un utilisateur\n */\nexport const updateUser = async (userId: string, updates: Partial<UserProfile>): Promise<void> => {\n  const partialUser: Partial<FirestoreUser> = {};\n\n  if (updates.currentLevel) partialUser.currentLevel = updates.currentLevel;\n  if (updates.targetLevel) partialUser.targetLevel = updates.targetLevel;\n  if (updates.weaknesses) partialUser.weaknesses = updates.weaknesses;\n  if (updates.completedExercises !== undefined)\n    partialUser.completedExercises = updates.completedExercises;\n  if (updates.totalScore !== undefined) partialUser.totalScore = updates.totalScore;\n  if (updates.lastActivity) partialUser.lastActivity = updates.lastActivity;\n\n  await updateDocument<FirestoreUser>(COLLECTION_NAME, userId, partialUser);\n};\n\n/**\n * Marque le test d'√©valuation comme compl√©t√© pour un utilisateur\n */\nexport const markAssessmentCompleted = async (\n  userId: string,\n  level?: \"A1\" | \"A2\" | \"B1\" | \"B2\" | \"C1\"\n): Promise<void> => {\n  const updates: Partial<FirestoreUser> = {\n    levelAssessed: true,\n    assessmentCompletedAt: new Date(),\n  };\n\n  if (level) {\n    updates.currentLevel = level;\n  }\n\n  await updateDocument<FirestoreUser>(COLLECTION_NAME, userId, updates);\n};\n\n/**\n * Supprime un utilisateur\n */\nexport const deleteUser = async (userId: string): Promise<void> => {\n  await deleteDocument(COLLECTION_NAME, userId);\n};\n\n/**\n * V√©rifie si un utilisateur existe\n */\nexport const userExists = async (userId: string): Promise<boolean> => {\n  return documentExists(COLLECTION_NAME, userId);\n};\n"],"names":["firebaseConfigGenerated","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","measurementId","isCapacitor","window","Capacitor","platform","_Capacitor","getPlatform","app","db","auth","storage","initializeApp","getFirestore","getAuth","getStorage","console","log","concat","error","errorMessage","Error","message","String","warn","isAuthenticated","currentUser","convertTimestamps","data","converted","_objectSpread","Object","keys","forEach","key","toDate","Array","isArray","getDocument","async","collectionName","documentId","logger","docRef","doc","docSnap","getDoc","exists","id","_error$message","_error$message2","_error$message3","_error$message4","code","includes","debug","collection","errorCode","COLLECTION_NAME","toUserProfile","firestoreUser","name","email","firstName","lastName","trim","currentLevel","targetLevel","strengths","weaknesses","completedExercises","totalScore","createdAt","lastActivity","updatedAt","getUserById","userId","getUserAssessmentStatus","levelAssessed","markAssessmentCompleted","level","updates","assessmentCompletedAt","Date","_auth$currentUser4","authUid","uid","dataKeys","dataSize","JSON","stringify","length","firestoreData","convertedDates","Timestamp","fromDate","match","e","value","updateDoc","now","info","_auth$currentUser5","updateDocument"],"ignoreList":[],"sourceRoot":""}